<h3>J-Fall 2014: Hands-on with Java 8</h3>
<hr/>
<a href="index.html">index</a><h2>Lab: Infinite streams</h2><h2>Introduction</h2><p>In this exercise we are building our own lazy stream called JStream and learn how to work with suppliers and how the new language features will help you create more elegant structures. We are using the definition of an algebraic type for this, see <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">link</a>. In short the definition of a stream is as follows:</p><p><code>
Stream s = Nil | Cons s (Stream s)
</code></p><p>We can define this stream in terms of two classes called <code>Cons</code> and <code>Nil</code>. The <code>Cons</code> classes uses a supplier which will postpone the evaluation of the next element by which we are able to generate an infinite stream.</p><p>Sources: <code>com.xebia.java8_7.infinite_list.JStream</code><br/>Tests: <code>com.xebia.java8_7.infinite_list.JStreamTest</code></p><h2>Exercises</h2><p>The cons and the nil classes are already supplied, in this exercise we will implement some behavior for this new stream.</p><h3>1. Implement of</h3><p>First to get familiar with the building blocks of the JStream class in this exercise we will create a stream consisting of the supplied elements. </p><p>Hint: consider writing a helper function which will create the stream based on the index in the elements array. In order to test the solution run the test case with the name <code>streamCreation</code>.</p><h3>2. Implement forEach</h3><p>In order to be able to process the elements of a stream we need to write a function called <code>forEach</code> which accepts an element of the stream and returns nothing. Test the solution run the test case with the name <code>forEach</code>. </p><h3>3. Implement start</h3><p>Until now the streams were still limited to a couple of elements, in this exercise we will create an infinite stream. As in Java streams an infinite stream takes on a starting point and a function to create the next element of the stream if needed. Test your implementation with the test case <code>infiniteStream</code>.</p><h3>4. Implement takeWhile</h3><p>Creating infinite streams is great but know we want work with the streams, for example taking n-number of elements of the stream. Implement the method <code>takeWhile</code> which will based on a predicate select the elements from the stream until the predicate false. For example:</p><p><code>
JStream.iterate(0, i -&gt; i + 1).takeWhile(i -&gt; i &lt;= 4)  
</code></p><p>should return 0,1,2,3,4.</p><h3>5. Implement fibonacci</h3><p>Until now we have been developing methods for creating and consuming streams, in this exercise with the previous implemented methods you need to write the fibonacci sequence in terms of an infinite stream. You can test your implementation with the test case <code>fibonacci</code>.</p><h3>6. Implement drop</h3><p>Write a method which will drop n-numbers of a stream. </p><h3>7. Implement zip</h3><p>In the BasicCollections API we wrote a zip function which creates a combined stream whose elements are the result of combining the elements of two streams. The function will be applied until one of the streams is exhausted.</p><br/>
<br/>
<hr/>
Xebia 2014