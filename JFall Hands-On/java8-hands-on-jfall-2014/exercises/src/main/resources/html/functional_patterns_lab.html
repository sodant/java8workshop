<h3>J-Fall 2014: Hands-on with Java 8</h3>
<hr/>
<a href="index.html">index</a><h1>Lab: Functional patterns</h1><h2>Introduction</h2><p>In this lab you will learn how to create your own 'higher order function'. A higher order function is a method that accepts a functional interface as input parameter. So far you have only used <em>existing</em> higher order functions like e.g. map, filter, groupBy etc. in the Stream API. In the lab below you will convert a solution that makes use of the template design-pattern into one that uses a higher order function. </p><p>As you will see, the higher order function approach is much more flexible, readable and requires less lines of code.</p><p><code>Sources: com.xebia.java8_4.functionalpatterns.FunctionalPatternLabs</code><br/><code>Tests: com.xebia.java8_4.functionalpatterns.FunctionalPatternLabs</code> </p><p><code>Sources: com.xebia.java8_4.functionalpatterns.ImperativeToFunctionalLabs</code><br/><code>Tests: com.xebia.java8_4.functionalpatterns.ImperativeToFunctionalLabsTest</code> </p><h2>Exercises</h2><p>This lab consists of two different labs both labs have the same goal to create your own higher order functions.</p><h2>Lab 1: FunctionalPatternLabs</h2><h3>1. Implement filterPersonsFunctionalImpl</h3><p>Implement <code>FunctionalPersonFilter.filterPersonsFunctionalImpl</code> in a functional style using the same processing logic as in the <code>PersonFilterTemplate.filterPersonsImperativeImpl</code></p><p>Hint: use <code>BufferedReader.lines()</code> as a starting point to the Stream API. As you can see not only Collections return Streams but <code>BufferedReader</code> too.</p><h3>2. Implement filterPersons</h3><p>Implement the higher order function <code>FunctionalPersonFilter.filterPerson</code>. In this functional implementation the filtering logic can directly be defined as a <code>Predicate</code> without the need to implement an abstract method like in the <code>PersonFilterTemplate</code> example. </p><p>Hint: Most of the processing logic written in exercise 1 (see above) can be re-used.</p><h2>Lab 2: ImperativeToFunctionalLabs</h2><h3>1. Implement filterAndGroupPersons</h3><p>Look at the imperative implementation <code>Lab1.Imperative.filterAndGroupPersons</code>. Provide a functional solution in <code>Lab1.Functional.filterAndGropupPersons</code> that yields the same result as the imperative example using the Stream API. The goal is to provide a functional approach for filtering persons with role Programmer, sorting them by name and group them by age. The method should return a map where the with key=age group (10, 20, 30 etc.) and value is a list of persons belonging to this group.</p><h3>2. Implement calculateLengthOfLongestWord</h3><p>Given the imperative implementation of the method calculateLengthOfLongestWord provide a functional approach for calculating the longest word in a list of lines. The words in a line can be separated by a space.</p><h3>3. Implement calculateLengthOfLongestWordInParallel</h3><p>Enhance the implementation of <code>Lab2.Functional.calculateLengthOfLongestWord</code> so that the calculation of the longest word per line is executed in parallel. </p><br/>
<br/>
<hr/>
Xebia 2014